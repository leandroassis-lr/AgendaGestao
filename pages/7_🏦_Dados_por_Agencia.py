import streamlit as st
import pandas as pd
import utils # Apenas para CSS e Login Check
import utils_chamados # <<< NOSSO NOVO ARQUIVO
from datetime import date, datetime
import re 
import html 

# Configura√ß√£o da P√°gina
st.set_page_config(page_title="Dados por Ag√™ncia - GEST√ÉO", page_icon="üè¶", layout="wide")
try:
    utils.load_css() # Tenta carregar o CSS
except:
    pass 

# --- Controle Principal de Login ---
if "logado" not in st.session_state or not st.session_state.logado:
    st.warning("Por favor, fa√ßa o login na p√°gina principal (app.py) antes de acessar esta p√°gina.")
    st.stop()
    
# Fun√ß√£o Helper para converter datas (evita erros)
def _to_date_safe(val):
    if val is None or pd.isna(val): return None
    if isinstance(val, date) and not isinstance(val, datetime): return val
    try:
        ts = pd.to_datetime(val, errors='coerce', dayfirst=True) # Tenta ler DD/MM/AAAA
        if pd.isna(ts): return None
        return ts.date()
    except Exception: return None

# --- Fun√ß√µes Helper da P√°gina ---
def extrair_e_mapear_colunas(df, col_map):
    """ Extrai e renomeia colunas com base em √≠ndices. """
    df_extraido = pd.DataFrame()
    colunas_originais = df.columns.tolist()
    
    # Valida√ß√£o (o CSV tem 29 colunas, T=19)
    if len(colunas_originais) < 20: 
        st.error(f"Erro: O arquivo carregado parece ter apenas {len(colunas_originais)} colunas. O formato esperado (com 20+ colunas) n√£o foi reconhecido.")
        return None
    try:
        col_nomes_originais = {idx: colunas_originais[idx] for idx in col_map.keys() if idx < len(colunas_originais)}
        df_para_renomear = df[list(col_nomes_originais.values())].copy() # Convertido para lista
        col_rename_map = {orig_name: db_name for idx, db_name in col_map.items() if idx in col_nomes_originais and (orig_name := col_nomes_originais[idx])}
        df_extraido = df_para_renomear.rename(columns=col_rename_map)
    except KeyError as e:
        st.error(f"Erro ao mapear colunas. Coluna esperada {e} n√£o encontrada no arquivo.")
        st.error(f"Colunas encontradas: {colunas_originais}")
        return None
    except Exception as e:
        st.error(f"Erro ao processar colunas: {e}"); return None
    return df_extraido

def formatar_agencia_excel(id_agencia, nome_agencia):
    """ Formata o ID e Nome da Ag√™ncia para o padr√£o 'AG 0001 - NOME' """
    try:
        id_agencia_limpo = str(id_agencia).split('.')[0]
        id_str = f"AG {int(id_agencia_limpo):04d}"
    except (ValueError, TypeError): id_str = str(id_agencia).strip() 
    nome_str = str(nome_agencia).strip()
    if nome_str.startswith(id_agencia_limpo):
         nome_str = nome_str[len(id_agencia_limpo):].strip(" -")
    return f"{id_str} - {nome_str}"


# --- Tela Principal da P√°gina ---
def tela_dados_agencia():
    st.markdown("<div class='section-title-center'>GEST√ÉO DE DADOS POR AG√äNCIA</div>", unsafe_allow_html=True)
    st.write(" ")
    
    # --- Roda a fun√ß√£o de cria√ß√£o/atualiza√ß√£o da tabela ---
    utils_chamados.criar_tabela_chamados()

    # --- 1. Importador de Chamados ---
    with st.expander("üì• Importar Novos Chamados (Excel/CSV)"):
        st.info(f"""
            Arraste seu arquivo Excel de chamados (formato `.xlsx` ou `.csv` com `;`) aqui.
            O sistema espera que a **primeira linha** contenha os cabe√ßalhos.
            As colunas necess√°rias (baseado no arquivo 'RelatorioAnexo...'):
            - **A:** Chamado (ID)
            - **B:** Codigo_Ponto (ID Ag√™ncia)
            - **C:** Nome (Nome Ag√™ncia)
            - **D:** UF
            - **J:** Servico
            - **K:** Projeto
            - **L:** Data_Agendamento (Formato DD/MM/AAAA)
            - **M:** Tipo_De_Solicitacao (ser√° salvo como 'Sistema')
            - **N:** Sistema (ser√° salvo como 'C√≥d. Equipamento')
            - **O:** Codigo_Equipamento (ser√° salvo como 'Nome Equipamento')
            - **Q:** Quantidade_Solicitada (ser√° salvo como 'Quantidade')
            - **T:** Gestor
            
            Se um `Chamado` (Coluna A) j√° existir, ele ser√° **atualizado**.
        """)
        uploaded_file = st.file_uploader("Selecione o arquivo Excel/CSV de chamados", type=["xlsx", "xls", "csv"], key="chamado_uploader")

        if uploaded_file is not None:
            try:
                if uploaded_file.name.endswith('.csv'):
                    df_raw = pd.read_csv(uploaded_file, sep=';', header=0, encoding='latin-1', keep_default_na=False, dtype=str) # L√™ tudo como string
                else:
                    df_raw = pd.read_excel(uploaded_file, header=0, keep_default_na=False, dtype=str) # L√™ tudo como string

                df_raw.dropna(how='all', inplace=True)
                if df_raw.empty: st.error("Erro: O arquivo est√° vazio."); st.stop()

                # --- Mapeamento (Q = 16) ---
                col_map = {
                    0: 'chamado_id', 1: 'agencia_id', 2: 'agencia_nome', 3: 'agencia_uf',
                    9: 'servico', 10: 'projeto_nome', 11: 'data_agendamento', 12: 'sistema',
                    13: 'cod_equipamento', 14: 'nome_equipamento',
